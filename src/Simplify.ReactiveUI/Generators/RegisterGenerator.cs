using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Simplify.ReactiveUI.Models;

namespace Simplify.ReactiveUI.Generators;

[Generator]
public class RegisterGenerator : IIncrementalGenerator
{
    private const string SplatRegisterAttribute =
        """
        #nullable enable

        namespace Simplify.ReactiveUI;

        [AttributeUsage(AttributeTargets.Class)]
        public class SplatRegisterAttribute : Attribute
        {
            /// <summary>
            /// The types array which is used for the registration.
            /// </summary>
            public Type[]? ServiceTypes { get; }
            
            /// <summary>
            /// An optional contract value which will indicates to only generate the value if this contract is specified.
            /// </summary>
            public string? Contract { get; }
            
            /// <summary>
            /// 
            /// </summary>
            public bool IncludeBaseClass { get; }
            
            /// <summary>
            /// 
            /// </summary>
            public bool IncludeInterfaces { get; }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="serviceTypes">The types array which is used for the registration.</param>
            /// <param name="contract">An optional contract value which will indicates to only generate the value if this contract is specified.</param>
            /// <param name="includeBaseClass"></param>
            /// <param name="includeInterfaces"></param>
            public SplatRegisterAttribute(
                Type[]? serviceTypes = null,
                string? contract = null,
                bool includeBaseClass = false,
                bool includeInterfaces = false)
            {
                ServiceTypes = serviceTypes;
                Contract = contract;
                IncludeBaseClass = includeBaseClass;
                IncludeInterfaces = includeInterfaces;
            }
        }
        """;

    private const string SplatRegisterConstantAttribute =
        """
        #nullable enable

        namespace Simplify.ReactiveUI;

        [AttributeUsage(AttributeTargets.Class)]
        public class SplatRegisterConstantAttribute : Attribute
        {
            public Type[]? ServiceTypes { get; }

            public string? Contract { get; }

            public bool IncludeBaseClass { get; }

            public bool IncludeInterfaces { get; }

            public SplatRegisterConstantAttribute(
                Type[]? serviceTypes = null,
                string? contract = null,
                bool includeBaseClass = false,
                bool includeInterfaces = false)
            {
                ServiceTypes = serviceTypes;
                Contract = contract;
                IncludeBaseClass = includeBaseClass;
                IncludeInterfaces = includeInterfaces;
            }
        }
        """;

    private const string SplatRegisterLazySingletonAttribute =
        """
        #nullable enable

        namespace Simplify.ReactiveUI;

        [AttributeUsage(AttributeTargets.Class)]
        public class SplatRegisterLazySingletonAttribute : Attribute
        {
            public Type[]? ServiceTypes { get; }
            
            public string? Contract { get; }
            
            public bool IncludeBaseClass { get; }
            
            public bool IncludeInterfaces { get; }
            
            public SplatRegisterLazySingletonAttribute(
                Type[]? serviceTypes = null,
                string? contract = null,
                bool includeBaseClass = false,
                bool includeInterfaces = false)
            {
                ServiceTypes = serviceTypes;
                Contract = contract;
                IncludeBaseClass = includeBaseClass;
                IncludeInterfaces = includeInterfaces;
            }
        }
        """;

    private const string SplatRegisterViewModelAttribute =
        """
        #nullable enable

        namespace Simplify.ReactiveUI;

        [AttributeUsage(AttributeTargets.Class)]
        public class SplatRegisterViewModelAttribute : Attribute
        {
            public Type ViewModel { get; }

            public SplatRegisterViewModelAttribute(Type viewModel)
            {
                ViewModel = viewModel;
            }
        }
        """;

    private const string RegisterClassTemplate =
        """
        //-------------------------------------------------------------------------------
        //<auto-generated>
        //    This code was generated by RegisterGenerator{{generatedAt}}.
        //</auto-generated>
        //-------------------------------------------------------------------------------

        {{reactiveUI}}using Splat;

        namespace Simplify.ReactiveUI;

        public static class SplatRegisterExtensions
        {
            /// <summary>
            /// Register all items using SplatRegisterAttribute, SplatRegisterConstantAttribute, SplatRegisterLazySingletonAttribute, SplatRegisterViewModelAttribute
            /// </summary>
            public static void RegisterAll(this IMutableDependencyResolver resolver)
            {
        {{registers}}
            }
        }
        """;

    private const string RegisterTemplate =
        """
                resolver.{{method}}({{implementationType}}{{serviceType}}{{contract}});
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("SplatRegisterAttribute.g.cs",
                SourceText.From(SplatRegisterAttribute, Encoding.UTF8)));

        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("SplatRegisterConstantAttribute.g.cs",
                SourceText.From(SplatRegisterConstantAttribute, Encoding.UTF8)));

        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("SplatRegisterLazySingletonAttribute.g.cs",
                SourceText.From(SplatRegisterLazySingletonAttribute, Encoding.UTF8)));

        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("SplatRegisterViewModelAttribute.g.cs",
                SourceText.From(SplatRegisterViewModelAttribute, Encoding.UTF8)));

        var registerProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Simplify.ReactiveUI.SplatRegisterAttribute",
                Predicate,
                RegisterTransform);

        var registerConstantProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Simplify.ReactiveUI.SplatRegisterConstantAttribute",
                Predicate,
                RegisterConstantTransform);

        var registerLazySingletonProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Simplify.ReactiveUI.SplatRegisterLazySingletonAttribute",
                Predicate,
                RegisterLazySingletonTransform);

        var registerViewModelProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Simplify.ReactiveUI.SplatRegisterViewModelAttribute",
                Predicate,
                RegisterViewModelTransform);

        var combinedData = registerProvider
            .Collect()
            .Combine(registerConstantProvider.Collect())
            .Combine(registerLazySingletonProvider.Collect())
            .Combine(registerViewModelProvider.Collect());

        context.RegisterSourceOutput(combinedData, Generate);
    }

    private void Generate(SourceProductionContext context,
        (((ImmutableArray<IReadOnlyList<RegisterInfoBase>> RegisterInfos,
            ImmutableArray<IReadOnlyList<RegisterInfoBase>> RegisterConstantInfos)
            Left, ImmutableArray<IReadOnlyList<RegisterInfoBase>> RegisterLazySingletonInfos) Left,
            ImmutableArray<IReadOnlyList<RegisterInfoBase>> RegisterViewModelInfos) args)
    {
        var registerInfos = args.Left.Left.RegisterInfos.IsDefaultOrEmpty
            ? []
            : args.Left.Left.RegisterInfos.SelectMany(r => r).ToList();

        var registerConstantInfos = args.Left.Left.RegisterConstantInfos.IsDefaultOrEmpty
            ? []
            : args.Left.Left.RegisterConstantInfos.SelectMany(r => r).ToList();

        var registerLazySingletonInfos = args.Left.RegisterLazySingletonInfos.IsDefaultOrEmpty
            ? []
            : args.Left.RegisterLazySingletonInfos.SelectMany(r => r).ToList();

        var registerViewModelInfos = args.RegisterViewModelInfos.IsDefaultOrEmpty
            ? []
            : args.RegisterViewModelInfos.SelectMany(r => r).ToList();

        var builder = new StringBuilder();
        foreach (var info in registerInfos)
            builder.AppendLine(RegisterTemplate
                .Replace("{{method}}", "Register")
                .Replace("{{implementationType}}", $"() => new {info.ImplementationType}()")
                .Replace("{{serviceType}}",
                    string.IsNullOrWhiteSpace(info.ServiceType) ? "" : $", typeof({info.ServiceType})")
                .Replace("{{contract}}", $", {(string.IsNullOrWhiteSpace(info.Contract) ? "null" : info.Contract)}"));

        foreach (var info in registerConstantInfos)
            builder.AppendLine(RegisterTemplate
                .Replace("{{method}}", "RegisterConstant")
                .Replace("{{implementationType}}", $"new {info.ImplementationType}()")
                .Replace("{{serviceType}}",
                    string.IsNullOrWhiteSpace(info.ServiceType) ? "" : $", typeof({info.ServiceType})")
                .Replace("{{contract}}", $", {(string.IsNullOrWhiteSpace(info.Contract) ? "null" : info.Contract)}"));

        foreach (var info in registerLazySingletonInfos)
            builder.AppendLine(RegisterTemplate
                .Replace("{{method}}", "RegisterLazySingleton")
                .Replace("{{implementationType}}", $"() => new {info.ImplementationType}()")
                .Replace("{{serviceType}}",
                    string.IsNullOrWhiteSpace(info.ServiceType) ? "" : $", typeof({info.ServiceType})")
                .Replace("{{contract}}", $", {(string.IsNullOrWhiteSpace(info.Contract) ? "null" : info.Contract)}"));

        foreach (var info in registerViewModelInfos)
            builder.AppendLine(RegisterTemplate
                .Replace("{{method}}", "Register")
                .Replace("{{implementationType}}", $"() => new {info.ImplementationType}()")
                .Replace("{{serviceType}}", $", typeof({info.ServiceType})")
                .Replace("{{contract}}", ", null"));

        var registers = builder.ToString(0, builder.Length - 2);

        var output = RegisterClassTemplate
#if DEBUG
            .Replace("{{generatedAt}}", $" at {DateTime.Now:s}")
#else
            .Replace("{{generatedAt}}", string.Empty)
#endif
            .Replace("{{reactiveUI}}", registerViewModelInfos.Count == 0 ? "" : "using ReactiveUI;\r\n")
            .Replace("{{registers}}", registers);

        context.AddSource("SplatRegisterExtensions.g.cs", SourceText.From(output, Encoding.UTF8));
    }

    private static bool Predicate(SyntaxNode node, CancellationToken token)
    {
        return true;
    }

    private static IReadOnlyList<RegisterInfoBase> RegisterTransform(GeneratorAttributeSyntaxContext syntaxContext,
        CancellationToken cancellationToken)
    {
        var infos = GetInfos(syntaxContext, cancellationToken);
        if (infos == null)
            return [];

        var (serviceTypes, className, contract) = infos.Value;

        if (serviceTypes == null)
            return [];

        if (serviceTypes.Count == 0)
            return
            [
                new RegisterInfo
                {
                    ImplementationType = className,
                    Contract = contract
                }
            ];

        return serviceTypes.Select(s => new RegisterInfo
        {
            ServiceType = s,
            ImplementationType = className,
            Contract = contract
        }).ToList();
    }

    private static IReadOnlyList<RegisterInfoBase> RegisterConstantTransform(
        GeneratorAttributeSyntaxContext syntaxContext,
        CancellationToken cancellationToken)
    {
        var infos = GetInfos(syntaxContext, cancellationToken);
        if (infos == null)
            return [];

        var (serviceTypes, className, contract) = infos.Value;

        if (serviceTypes == null)
            return [];

        if (serviceTypes.Count == 0)
            return
            [
                new RegisterConstantInfo
                {
                    ImplementationType = className,
                    Contract = contract
                }
            ];

        return serviceTypes.Select(s => new RegisterConstantInfo
        {
            ServiceType = s,
            ImplementationType = className,
            Contract = contract
        }).ToList();
    }

    private static IReadOnlyList<RegisterInfoBase> RegisterLazySingletonTransform(
        GeneratorAttributeSyntaxContext syntaxContext,
        CancellationToken cancellationToken)
    {
        var infos = GetInfos(syntaxContext, cancellationToken);
        if (infos == null)
            return [];

        var (serviceTypes, className, contract) = infos.Value;

        if (serviceTypes.Count == 0)
            return
            [
                new RegisterLazySingletonInfo
                {
                    ImplementationType = className,
                    Contract = contract
                }
            ];

        return serviceTypes.Select(s => new RegisterLazySingletonInfo
        {
            ServiceType = s,
            ImplementationType = className,
            Contract = contract
        }).ToList();
    }

    private IReadOnlyList<RegisterInfoBase> RegisterViewModelTransform(
        GeneratorAttributeSyntaxContext syntaxContext,
        CancellationToken cancellationToken)
    {
        var classSymbol = syntaxContext.SemanticModel.GetDeclaredSymbol(syntaxContext.TargetNode);
        if (classSymbol is not INamedTypeSymbol namedTypeSymbol)
            return [];

        var attribute = syntaxContext.Attributes.Single();
        var viewModel = attribute.ConstructorArguments[0].Value?.ToString();
        if (viewModel == null)
            return [];

        var className = namedTypeSymbol.ToDisplayString();
        return
        [
            new RegisterViewModelInfo
            {
                ServiceType = $"IViewFor<{viewModel}>",
                ImplementationType = className,
                Contract = null
            }
        ];
    }

    private static (List<string> ServiceTypes, string ImplementationType, string? Contract)? GetInfos(
        GeneratorAttributeSyntaxContext syntaxContext,
        CancellationToken _)
    {
        var classSymbol = syntaxContext.SemanticModel.GetDeclaredSymbol(syntaxContext.TargetNode);
        if (classSymbol is not INamedTypeSymbol namedTypeSymbol)
            return null;

        var attribute = syntaxContext.Attributes.Single();
        var serviceTypes = attribute.ConstructorArguments[0].Values.IsDefaultOrEmpty
            ? []
            : attribute.ConstructorArguments[0].Values
                .Select(t => t.Value?.ToString() ?? "")
                .Where(x => !string.IsNullOrEmpty(x))
                .Distinct()
                .ToList();

        var contract = attribute.ConstructorArguments[1].Value as string;
        var includeBaseType = attribute.ConstructorArguments[2].Value as bool? ?? false;
        var includeInterfaces = attribute.ConstructorArguments[3].Value as bool? ?? false;

        var className = namedTypeSymbol.ToDisplayString();
        var baseClassName = GetDirectBaseClassName(namedTypeSymbol);

        if (includeBaseType && baseClassName != null && !serviceTypes.Contains(baseClassName))
            serviceTypes.Add(baseClassName);

        if (includeInterfaces)
        {
            var interfaces = namedTypeSymbol.Interfaces
                .Where(i => IsDirectlyImplementedInterface(namedTypeSymbol, i))
                .ToList();
            foreach (var @interface in interfaces)
            {
                var interfaceName = @interface.ToDisplayString();
                if (!serviceTypes.Contains(interfaceName))
                    serviceTypes.Add(interfaceName);
            }
        }

        return (serviceTypes, className, contract);
    }

    private static bool IsDirectlyImplementedInterface(INamedTypeSymbol namedTypeSymbol, ITypeSymbol @interface)
    {
        if (namedTypeSymbol.BaseType == null)
            return true;

        return !namedTypeSymbol.BaseType.Interfaces.Any(i =>
            SymbolEqualityComparer.Default.Equals(i, @interface));
    }

    private static string? GetDirectBaseClassName(INamedTypeSymbol namedTypeSymbol)
    {
        var directBaseClass = namedTypeSymbol.BaseType;
        if (directBaseClass == null)
            return null;

        var baseClassFullName = directBaseClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return baseClassFullName is "System.Object" or "object" ? null : baseClassFullName;
    }
}
